buildscript {
	ext {
		springBootVersion = '1.3.6.RELEASE'
	}
	repositories {
		mavenCentral()
		jcenter()
	}
	dependencies {
		classpath("org.springframework.boot:spring-boot-gradle-plugin:${springBootVersion}")
		classpath('se.transmode.gradle:gradle-docker:1.2')
		classpath 'org.ajoberstar:grgit:1.1.0'
	}
}


plugins {
	id "io.spring.dependency-management" version "0.6.1.RELEASE"
}


apply plugin: 'java'
apply plugin: 'eclipse'
apply plugin: 'spring-boot'
apply plugin: 'idea'
apply plugin: 'groovy'
apply plugin: 'docker'

if (project.hasProperty('projectversion')) {
  project.version = projectversion
} else {
  project.version = '5.0.0'
}

jar {
	baseName = 'runakuna-backend'
	version = project.version
}
sourceCompatibility = 1.8
targetCompatibility = 1.8


ext {
	snippetsDir = file('build/generated-snippets')
}
ext['spring.version']='4.3.1.RELEASE'



repositories {
	mavenCentral()
	mavenLocal()
	jcenter()
	//maven  {
	//	url "http://celticci.tss.com.pe:8081/nexus/content/repositories/thirdparty"
	//}
	//maven { url 'http://proget.tss.com.pe:81/maven/tsi-maven/' }

}



dependencies {

	// log
	compile ('log4j:log4j:1.2.17')
	// spring
	compile('org.springframework.boot:spring-boot-starter-web')
	compile('org.springframework.boot:spring-boot-starter-thymeleaf')
	compile('org.springframework.boot:spring-boot-starter-data-jpa')
	compile('org.springframework.boot:spring-boot-starter-data-rest')
	compile('org.springframework.boot:spring-boot-starter-mail')
	compile('org.springframework.boot:spring-boot-starter-security')
	compile('org.springframework.cloud:spring-cloud-starter-config:1.0.3.RELEASE') { exclude(group: 'ch.qos.logback') }
	compile('org.apache.poi:poi-ooxml:3.10.1')
	compile('org.springframework:spring-jdbc')
	compile('org.projectlombok:lombok:1.12.6')
	//compile('com.microsoft.sqlserver:sqljdbc4:4.0')
	compile('mysql:mysql-connector-java')
	compile('net.sourceforge.jtds:jtds:1.3.1')
	compile('org.springframework.hateoas:spring-hateoas:0.19.0.RELEASE')

	compile('io.jsonwebtoken:jjwt:0.6.0')
	compile('joda-time:joda-time:2.1')
	compile('org.apache.commons:commons-lang3:3.3.2')

	compile('net.sf.dozer:dozer:5.5.1')

	compile('com.google.code.gson:gson:2.6.2')
	compile group: 'org.apache.httpcomponents', name: 'httpclient', version: '4.5.2'


	compile group: 'net.sf.jasperreports', name: 'jasperreports', version: '6.3.0'

	compile('com.lowagie:itext:2.1.7')
	compile group: 'org.olap4j', name: 'olap4j', version: '1.2.0'


	testCompile('org.springframework.boot:spring-boot-starter-test')
	testCompile('org.springframework.restdocs:spring-restdocs-mockmvc')

}


eclipse {
	classpath {
		containers.remove('org.eclipse.jdt.launching.JRE_CONTAINER')
		containers 'org.eclipse.jdt.launching.JRE_CONTAINER/org.eclipse.jdt.internal.debug.ui.launcher.StandardVMType/JavaSE-1.8'
	}
}


sourceSets {
	funcTests {
		compileClasspath += main.output + test.output
		runtimeClasspath += main.output + test.output
	}
}


ext['hibernate.version'] = '5.0.7.Final'

configurations {
	funcTestsCompile.extendsFrom testCompile
	funcTestsRuntime.extendsFrom testRuntime
}


task funcTests(type: Test) {
	testClassesDir = sourceSets.funcTests.output.classesDir
	classpath = sourceSets.funcTests.runtimeClasspath
}

task wrapper(type: Wrapper) {
	gradleVersion = '2.12'
}

bootRun {
	addResources = true
}



springBoot {
	mainClass = "pe.com.empresa.rk.RunakunaBackendApplication"
}

group = 'empresa'
task buildDocker(type: Docker, dependsOn: assemble) {
	push = false
	applicationName = jar.baseName
	dockerfile = file('src/main/docker/Dockerfile')
	doFirst {
		copy {
			from jar
			into stageDir
		}
	}
}

import org.codehaus.groovy.runtime.*
import org.eclipse.jgit.api.*

def getGitBranchCommit() {
	try {
		def git = org.ajoberstar.grgit.Grgit.open(file('.'))
		def revision = git.head().abbreviatedId
		return revision
	} catch (IOException ex) {
		return "UNKNOWN"
	}

}

processResources {
	filesMatching("**/application.properties") {
		expand (
				"prodVersion": gradle.gradleVersion,
				"revision": getGitBranchCommit(),
				"buildTimestamp": DateGroovyMethods.format(new Date(), 'yyyy-MM-dd HH:mm'),
				"prodBuild": project.version
		)
	}
}

processResources.outputs.upToDateWhen{ false }


task printVersion {
	// any code that goes here is part of configuring the task
	// this code will always get run, even if the task is not executed
	doLast { // add a task action
		// any code that goes here is part of executing the task
		// this code will only get run if and when the task gets executed
		println project.version
	}
}

task buildInfo {
	println project.version + "-" + getGitBranchCommit()
}